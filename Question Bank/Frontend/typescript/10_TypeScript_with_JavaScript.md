# TYPESCRIPT WITH JAVASCRIPT ANSWERS

---

## 61. Can TypeScript run in browser?

### Answer:
- **No**, TypeScript **cannot run directly** in browsers
- Browsers only understand **JavaScript**
- TypeScript must be **compiled (transpiled) to JavaScript** first
- The compiled JavaScript then runs in the browser
- Some tools (like Deno) can run TypeScript directly via JIT compilation

### Theoretical Keywords:
**Browser compatibility**, **Transpilation required**, **JavaScript output**,  
**Build step**, **Compilation**, **Runtime environment**

### Workflow:
```
TypeScript (.ts) → tsc compiler → JavaScript (.js) → Browser

Development:
1. Write TypeScript code
2. Compile with tsc or bundler (webpack, vite)
3. Browser loads compiled JavaScript
```

### Example:
```typescript
// Source: app.ts
interface User {
    name: string;
    age: number;
}

const greet = (user: User): string => {
    return `Hello, ${user.name}!`;
};

const user: User = { name: "John", age: 25 };
console.log(greet(user));

// Compiled: app.js (what browser receives)
"use strict";
const greet = (user) => {
    return `Hello, ${user.name}!`;
};
const user = { name: "John", age: 25 };
console.log(greet(user));

// Note: Types are completely erased in output
```

### HTML Integration:
```html
<!DOCTYPE html>
<html>
<head>
    <title>TypeScript App</title>
</head>
<body>
    <!-- Reference compiled JavaScript, NOT TypeScript -->
    <script src="dist/app.js"></script>
    
    <!-- ❌ This won't work: -->
    <!-- <script src="src/app.ts"></script> -->
</body>
</html>
```

---

## 62. How is TypeScript code converted to JavaScript?

### Answer:
- TypeScript uses the **tsc (TypeScript Compiler)** to compile code
- Compilation process: **Parse → Type Check → Emit JavaScript**
- **Types are erased** during compilation (type erasure)
- Output JavaScript version controlled by **target** option
- Can also use bundlers (webpack, vite, esbuild) for compilation

### Theoretical Keywords:
**tsc compiler**, **Transpilation**, **Type erasure**, **AST**,  
**Emit phase**, **Bundlers**, **Build process**

### Compilation Steps:
```
1. Parse TypeScript → Abstract Syntax Tree (AST)
2. Type checking → Validate types, report errors
3. Transform → Convert to target JavaScript version
4. Emit → Write .js and .d.ts files
```

### Example:
```bash
# Install TypeScript
npm install -g typescript

# Compile single file
tsc app.ts

# Compile with config
tsc                    # Uses tsconfig.json
tsc --project tsconfig.json

# Watch mode
tsc --watch

# Compile to specific target
tsc app.ts --target ES2020

# Compile to specific directory
tsc app.ts --outDir dist
```

### Code Transformation:
```typescript
// Source: TypeScript
interface Product {
    id: number;
    name: string;
    price: number;
}

class ShoppingCart {
    private items: Product[] = [];
    
    add(product: Product): void {
        this.items.push(product);
    }
    
    getTotal(): number {
        return this.items.reduce((sum, item) => sum + item.price, 0);
    }
}

const cart = new ShoppingCart();
cart.add({ id: 1, name: "Book", price: 29.99 });

// Output: JavaScript (ES2020 target)
"use strict";
class ShoppingCart {
    constructor() {
        this.items = [];
    }
    add(product) {
        this.items.push(product);
    }
    getTotal() {
        return this.items.reduce((sum, item) => sum + item.price, 0);
    }
}
const cart = new ShoppingCart();
cart.add({ id: 1, name: "Book", price: 29.99 });

// Notice: interface removed, types removed, private becomes regular property
```

---

## 63. What is declaration file (`.d.ts`)?

### Answer:
- **Declaration files** (`.d.ts`) contain **type information only**
- No runtime code, just **type declarations**
- Allow TypeScript to understand **JavaScript libraries**
- Provide **IntelliSense** and **type checking** for JS code
- Can be auto-generated by tsc with `declaration: true`

### Theoretical Keywords:
**Type definitions**, **Ambient declarations**, **DefinitelyTyped**,  
**@types packages**, **Type information**, **Library typing**

### Example:
```typescript
// math.d.ts - Declaration file
declare function add(a: number, b: number): number;
declare function multiply(a: number, b: number): number;

declare const PI: number;

declare interface MathConfig {
    precision: number;
    rounding: "floor" | "ceil" | "round";
}

declare class Calculator {
    constructor(config?: MathConfig);
    add(a: number, b: number): number;
    subtract(a: number, b: number): number;
}

// Usage in TypeScript
import { add, Calculator } from './math';

const result = add(1, 2);  // TypeScript knows types
const calc = new Calculator({ precision: 2, rounding: "round" });
```

### Module Declaration:
```typescript
// global.d.ts
declare module "my-library" {
    export function doSomething(value: string): number;
    export interface Config {
        debug: boolean;
        timeout: number;
    }
}

// Usage
import { doSomething, Config } from "my-library";
const result = doSomething("test");  // number
```

### Global Type Augmentation:
```typescript
// types/global.d.ts
declare global {
    interface Window {
        myApp: {
            version: string;
            init(): void;
        };
    }
}

export {};  // Makes this a module

// Usage
window.myApp.version;  // TypeScript knows about myApp
```

---

## 64. Why are declaration files used?

### Answer:
Declaration files serve several important purposes:
- **Type safety** for JavaScript libraries
- **IDE support** (IntelliSense, autocomplete, documentation)
- **Compile-time checking** for third-party code
- **Documentation** of library APIs
- **Bridge** between JavaScript and TypeScript

### Theoretical Keywords:
**Type safety**, **IDE support**, **Third-party libraries**,  
**API documentation**, **DefinitelyTyped**, **@types**

### Use Cases:
```typescript
// 1. Using JavaScript library in TypeScript

// Without declaration file:
import lodash from 'lodash';
lodash.chunk([1, 2, 3], 2);  // ❌ No type information, possibly any

// With declaration file (@types/lodash):
import _ from 'lodash';
_.chunk([1, 2, 3], 2);  // ✅ Type-safe: _.chunk<number>(array, size): number[][]


// 2. Publishing TypeScript library

// my-library/index.ts
export function greet(name: string): string {
    return `Hello, ${name}!`;
}

// Generated: my-library/index.d.ts
export declare function greet(name: string): string;

// Consumers get types even if they import compiled JS


// 3. Typing your own JavaScript code

// legacy-code.js (JavaScript)
function calculateTax(amount, rate) {
    return amount * rate;
}

// legacy-code.d.ts (Declaration file)
declare function calculateTax(amount: number, rate: number): number;

// Now TypeScript understands legacy-code.js


// 4. Global type definitions

// jquery.d.ts
declare var $: JQueryStatic;
declare var jQuery: JQueryStatic;

interface JQueryStatic {
    (selector: string): JQuery;
    ajax(url: string, settings?: JQueryAjaxSettings): JQueryXHR;
}

// Usage
$('#myElement').hide();  // Type-safe jQuery
```

### DefinitelyTyped Repository:
```bash
# Install type definitions from @types
npm install --save-dev @types/lodash
npm install --save-dev @types/express
npm install --save-dev @types/node
npm install --save-dev @types/react

# Types are automatically used by TypeScript
```

---

## 65. How to use third-party JavaScript libraries in TypeScript?

### Answer:
There are several ways to use JavaScript libraries in TypeScript:
1. **Install @types packages** (most common)
2. **Use bundled types** (library includes .d.ts)
3. **Create custom declarations**
4. **Use `any` type** (not recommended)

### Theoretical Keywords:
**@types packages**, **DefinitelyTyped**, **Bundled types**,  
**Custom declarations**, **Module resolution**, **Type acquisition**

### Example:
```typescript
// ========================================
// Method 1: @types packages (DefinitelyTyped)
// ========================================

// Terminal:
// npm install lodash
// npm install --save-dev @types/lodash

import _ from 'lodash';
_.chunk([1, 2, 3, 4], 2);  // ✅ Fully typed


// ========================================
// Method 2: Library includes types
// ========================================

// Some libraries include types (check package.json "types" field)
// npm install axios  (includes types)

import axios from 'axios';
axios.get<User>('/api/user');  // ✅ Fully typed


// ========================================
// Method 3: Create custom declaration file
// ========================================

// my-js-lib.d.ts
declare module 'my-js-lib' {
    export function doSomething(value: string): number;
    export interface Options {
        debug?: boolean;
        timeout?: number;
    }
    export default function init(options: Options): void;
}

// Usage
import init, { doSomething } from 'my-js-lib';
init({ debug: true });
doSomething('test');


// ========================================
// Method 4: Quick fix with any (not recommended)
// ========================================

// For untyped library, create minimal declaration
declare module 'untyped-library';

// Or in tsconfig.json
{
    "compilerOptions": {
        "noImplicitAny": false  // ❌ Not recommended
    }
}


// ========================================
// Method 5: Inline require with any
// ========================================

const untypedLib: any = require('untyped-library');
untypedLib.anyMethod();  // No type checking
```

### tsconfig.json for Type Acquisition:
```json
{
  "compilerOptions": {
    // Automatic type acquisition
    "typeRoots": [
      "./node_modules/@types",
      "./types"  // Custom types directory
    ],
    
    // Specific types to include
    "types": ["node", "jest", "lodash"],
    
    // Allow importing JS files
    "allowJs": true,
    "checkJs": true
  }
}
```

### Checking if Types Exist:
```bash
# Check if @types package exists
npm search @types/library-name

# Or visit: https://www.typescriptlang.org/dt/search

# Check package.json for bundled types
# Look for "types" or "typings" field
```

---
